# Дана последовательность чисел. Получить список уникальных элементов заданной последовательности.
# Пример:
#  [1, 2, 3, 5, 1, 5, 3, 10] => [2, 10]

# Примеры использования быстрых функций:
a = ['312', '123', '768']
print(a)
a = list(map(int, a))
print(a)
#  или:
a = ['312', '123', '768']
print(a)
a = [int(item) for item in a if item.isdigit()] # будем брать из списка а элемент, превращать его в int и возвращать,
                                                # только при условии, что он - цифра
print(a)

b = ['312', '+', '123', '-', '768']
b = list(filter(lambda x: int(x) if x.isdigit() else x, b)) # фильтр принимает условия и принимает элементы. Лямда принимает на вход число
                                                            # и превращает его в int при условии, что элемент это число, иначе, просто возвращает исходный элемент
                                                            # через фильтр не получится, т.к. фильтр закидывает данные в итоговый результат, если вернулось True, 
                                                            # а у нас ни True ни False не возвращается, а выполняется действие.
# решать надо через map 
b = list(map(lambda x: int(x) if x.isdigit() else x, b))
print(b)

# Немного теории:

#                    List Comprehension из чего он состоит - у него 3 части:
# 1 что сделать с элементом? или какой элемент?
# 2 с каким элементом?
# 3 при каком условии
input_list = [1, 2, 3, 5, 1, 5, 3, 10]
res = [item for item in input_list] # в res надо записать item который берем из input_list. 
                                    # Такая запись перетянет все элемннты из одного списка в другой
res = [item for item in input_list if input_list.count(item) == 1]  # в res надо записать item который берем из input_list,
                                                                    # при условии что это уникальное число (т.к. встречается в списке 1 раз)
                                                                    # Такая запись перетянет только уникальные элементы

#                           filter
# 1. фильтр ждет условие при котором он будет работать
# 2. фильтр ждет элементы которые надо фильтровать

res_1 = tuple(filter(lambda x: x >= 3, input_list)) # list - список, tuple - кортеж
print(f'res_1 = {res_1}')

# List Comprehension и filter могут генерировать из исходной последовательности по условию несколько элементов

#               map
# map - сколько элементов пришло, столько и уйдет, map просто преобразует эти элементы
# map нужно:
# 1. набор элементов
# 2. инструкцию - что с этими элементами делать?

list_in = ['312', 'try', '123', 'ghjft', '768']

res_2 = list(map(lambda x: int(x) if x.isdigit() else x, list_in))
print(res_2)



#  Решение задачи:
list_1 = [1, 2, 3, 5, 1, 5, 3, 10]
list_2 = [i for i in list_1 if list_1.count(i) == 1]
list_3 = list(filter(lambda x: x if list_1.count(x) == 1 else not x, list_1))
# Поскольку по факту нет условия else, то правильнее будет упростить:
list_4 = list(filter(lambda x: list_1.count(x) == 1, list_1))
print(f'{list_1} => {list_2}')
print(f'{list_1} => {list_3}')
print(f'{list_1} => {list_4}')